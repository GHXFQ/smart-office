"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAttr = exports.getBtnSpacing = exports.getBtnAttributes = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _colors = require("../tokens/colors");

var _sizes = require("../tokens/sizes");

var _spacing = _interopRequireDefault(require("../tokens/spacing"));

var colors = _interopRequireWildcard(require("../tokens/color"));

var _misc = _interopRequireDefault(require("../tokens/misc"));

var _lodashEs = require("lodash-es");

var _commonHelper = require("../helpers/commonHelper");

var propsBtnColors = (0, _objectSpread2["default"])({}, colors);
var appearances = {
  "default": {
    text: _colors.button["default"].text,
    icon: _colors.button["default"].icon,
    background: _colors.button["default"].background,
    border: _colors.button["default"].border,
    hoverBackground: _colors.button["default"].backgroundHover,
    hoverBorder: _colors.button["default"].borderHover,
    focusBackground: _colors.button["default"].backgroundFocus,
    focusBorder: _colors.button["default"].borderFocus,
    activeBackground: _colors.button["default"].backgroundActive,
    activeBorder: _colors.button["default"].borderActive,
    loadingInverse: false
  },
  outline: {
    text: _colors.button.outline.text,
    icon: _colors.button.outline.icon,
    background: _colors.button.outline.background,
    border: _colors.button.outline.border,
    hoverBackground: _colors.button.outline.backgroundHover,
    hoverBorder: _colors.button.outline.borderHover,
    hoverText: _colors.button.outline.hoverText,
    focusBackground: _colors.button.outline.backgroundFocus,
    focusBorder: _colors.button.outline.borderFocus,
    activeBackground: _colors.button.outline.backgroundActive,
    activeBorder: _colors.button.outline.borderActive,
    loadingInverse: false
  },
  link: {
    text: _colors.button.link.text,
    icon: _colors.button.link.icon,
    background: "transparent",
    border: "transparent",
    hoverText: _colors.button.link.hover,
    hoverBackground: "transparent",
    hoverBorder: "transparent",
    focusText: _colors.button.link.focus,
    focusBackground: "transparent",
    focusBorder: "transparent",
    loadingInverse: false
  }
};
var buttonSizes = {
  large: {
    lineHeight: _sizes.button.large.height,
    minWidth: "35rem",
    padding: _spacing["default"].medium,
    fontSize: "1.8rem",
    iconSize: 14,
    activeShadow: "0 0.4rem 0.6rem"
  },
  "default": {
    lineHeight: _sizes.button["default"].height,
    minWidth: "15rem",
    padding: _spacing["default"].small,
    fontSize: "1.6rem",
    iconSize: 12,
    activeShadow: "0 0.4rem 0.6rem"
  },
  compressed: {
    lineHeight: _sizes.button.compressed.height,
    minWidth: "auto",
    padding: _spacing["default"].small,
    fontSize: "1.4rem",
    iconSize: 10,
    activeShadow: "0 0.3rem 0.6rem"
  },
  small: {
    lineHeight: _sizes.button.small.height,
    minWidth: "auto",
    padding: _spacing["default"].small,
    fontSize: "1.4rem",
    iconSize: 10,
    activeShadow: "0 0.3rem 0.6rem"
  }
};

var getBtnSpacing = function getBtnSpacing(props) {
  return props.text ? _spacing["default"].xsmall : 0;
};

exports.getBtnSpacing = getBtnSpacing;

var getBtnAttributes = function getBtnAttributes(props) {
  var isOutline = props.appearance === _misc["default"].button.appearances.outline;
  var isLink = props.appearance === _misc["default"].button.appearances.link;
  var disabledColor = propsBtnColors[_misc["default"].button.disabledColor];
  var activeColor = (0, _lodashEs.get)(propsBtnColors, "".concat(props.btnColor), disabledColor);
  var propsBtnColor = props.disabled ? disabledColor : activeColor; // Get the styles for the button's selected appearance.

  var appearanceStyles = appearances[props.appearance] || appearances["default"]; // Get the styles for the button's selected size.

  var sizeStyles = isLink ? buttonSizes.compressed : buttonSizes[props.size] || buttonSizes["default"]; // Merge the two style hashes together to create the base styles.

  var styles = (0, _objectSpread2["default"])({}, appearanceStyles, sizeStyles);
  styles.borderWidth = "0.1rem"; //define button colors for  button according to outline

  if (isOutline) {
    //outline button with propsBtnColor
    styles.background = propsBtnColors.white;
    styles.text = propsBtnColor.z500;
    styles.hoverText = propsBtnColor.z700; // styles.background;

    styles.border = propsBtnColor.z400;
    styles.hoverBackground = (0, _commonHelper.getRGBAFromHex)(propsBtnColor.z500, 0.04);
    styles.hoverBorder = propsBtnColor.z600;
    styles.focusBackground = colors.grey.z95;
    styles.focusBorder = propsBtnColor.z600;
    styles.activeBackground = (0, _commonHelper.getRGBAFromHex)(propsBtnColor.z500, 0.16);
    styles.activeBorder = propsBtnColor.z600;
    styles.customBoxShadow = "unset";
  } else if (isLink) {
    styles.border = "transparent";
    styles.background = "transparent";
    styles.border = "transparent";
    styles.text = propsBtnColor.z500;
    styles.hoverText = propsBtnColor.z600;
    styles.hoverBackground = "transparent"; // styles.hoverBorder = "transparent";

    styles.focusBackground = "transparent"; // styles.focusBorder = shadow;

    styles.activeBackground = "transparent"; // styles.activeBorder = shadow;

    styles.customBoxShadow = "none";
    styles.borderWidth = 0;
  } else {
    var shadow = "rgba(0,0,0,0.5)"; //solid button with propsBtnColor

    styles.background = propsBtnColor.z500;
    styles.border = propsBtnColor.z500;
    styles.hoverBackground = propsBtnColor.z600; //hoverColor;
    // styles.hoverBorder = "transparent";

    styles.focusBackground = shadow; // styles.focusBorder = shadow;

    styles.activeBackground = propsBtnColor.z600; // styles.activeBorder = shadow;

    styles.customBoxShadow = "".concat(styles.activeShadow, " rgba(0,0,0,.16)"); //"inset 0 0 0.8rem " + shadow;

    styles.borderWidth = 0;
  } // If the loading state is set, override some of the styles.


  if (!props.disabled && props.loading) {
    styles.hoverText = isOutline ? styles.text : styles.hoverText; // styles.border = isOutline ? styles.border : styles.hoverBorder;
    // styles.focusBorder = isOutline ? styles.focusBorder : styles.hoverBorder;
    // styles.activeBorder = isOutline ? styles.activeBorder : styles.hoverBorder;
  } // If the button contains only an icon and no text, override some of the styles.


  if (props.icon && !props.text) {
    // styles.padding = spacing.xsmall;
    styles.minWidth = "3.6rem"; // styles.icon = btnColor.link.icon;
  }

  if (props.fontSize) {
    styles.fontSize = props.fontSize;
    styles.iconSize = parseFloat(props.fontSize) !== parseInt(props.fontSize) ? parseFloat(props.fontSize) * 10 : parseFloat(props.fontSize);
  }

  return styles;
};

exports.getBtnAttributes = getBtnAttributes;

var getAttr = function getAttr(key) {
  return function (props) {
    return getBtnAttributes(props)[key];
  };
};

exports.getAttr = getAttr;