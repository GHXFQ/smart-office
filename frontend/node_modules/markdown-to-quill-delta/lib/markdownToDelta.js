import { fromMarkdown } from 'mdast-util-from-markdown';
import { toMarkdown } from 'mdast-util-to-markdown';
import { gfmFromMarkdown, gfmToMarkdown } from 'mdast-util-gfm';
import { gfm } from 'micromark-extension-gfm';
import { last } from 'lodash-es';
const getPreviousType = (ancestors, node) => {
    var _a, _b;
    const child = (_a = last(ancestors)) === null || _a === void 0 ? void 0 : _a.children;
    const previousType = (_b = child === null || child === void 0 ? void 0 : child[child.indexOf(node) - 1]) === null || _b === void 0 ? void 0 : _b.type;
    return previousType !== null && previousType !== void 0 ? previousType : 'firstOne';
};
const getNextType = (ancestors, node) => {
    var _a, _b;
    const child = (_a = last(ancestors)) === null || _a === void 0 ? void 0 : _a.children;
    const nextType = (_b = child === null || child === void 0 ? void 0 : child[child.indexOf(node) + 1]) === null || _b === void 0 ? void 0 : _b.type;
    return nextType !== null && nextType !== void 0 ? nextType : 'lastOne';
};
const root = ({ node, process: handle, ancestors }) => {
    if (node.type !== 'root') {
        return;
    }
    ;
    node.children.forEach((it) => handle(it, [...ancestors, node]));
    return true;
};
const paragraph = ({ node, process: handle, ancestors, ops }) => {
    if (node.type !== 'paragraph') {
        return;
    }
    ;
    node.children.forEach((it) => handle(it, [...ancestors, node]));
    ops.push({ insert: '\n' });
    // if (['paragraph', 'code', 'heading'].includes(getNextType(ancestors, node))) {
    //   ops.push({ insert: '\n' } as Op)
    // }
    return true;
};
const text = ({ node, ancestors, ops }) => {
    if (node.type !== 'text') {
        return;
    }
    const attrs = {};
    if (ancestors.find((it) => it.type === 'strong')) {
        attrs.bold = true;
    }
    if (ancestors.find((it) => it.type === 'emphasis')) {
        attrs.italic = true;
    }
    if (ancestors.find((it) => it.type === 'delete')) {
        attrs.strike = true;
    }
    if (Object.keys(attrs).length > 0) {
        ops.push({
            insert: node.value,
            attributes: attrs,
        });
    }
    else {
        ops.push({
            insert: node.value,
        });
    }
    return true;
};
const strong = ({ node, ancestors, ops, process: handle }) => {
    if (node.type !== 'strong' &&
        node.type !== 'emphasis' &&
        node.type !== 'delete') {
        return;
    }
    const attrs = {};
    if (node.type === 'strong') {
        attrs.bold = true;
    }
    if (node.type === 'emphasis') {
        attrs.italic = true;
    }
    if (node.type === 'delete') {
        attrs.strike = true;
    }
    ;
    node.children.forEach((it) => handle(it, [...ancestors, node]));
    return true;
};
const heading = ({ node, ancestors, ops, process: handle }) => {
    if (node.type !== 'heading') {
        return;
    }
    ;
    node.children.forEach((it) => handle(it, [...ancestors, node]));
    ops.push({
        insert: '\n',
        attributes: {
            header: node.depth,
        },
    });
    return true;
};
const list = ({ node, ancestors, process: handle }) => {
    if (node.type !== 'list') {
        return;
    }
    ;
    node.children.forEach((it) => handle(it, [...ancestors, node]));
    // if (getNextType(ancestors, node) === 'list') {
    //   ops.push({ insert: '\n' } as Op)
    // }
    return true;
};
const listItem = ({ node, ancestors, ops, process: handle }) => {
    var _a, _b;
    if (node.type !== 'listItem') {
        return;
    }
    const item = node;
    item.children
        .filter((it) => it.type !== 'list')
        .forEach((it) => handle(it, [...ancestors, node]));
    if (((_a = last(ops)) === null || _a === void 0 ? void 0 : _a.insert) === '\n' && !((_b = last(ops)) === null || _b === void 0 ? void 0 : _b.attributes)) {
        ops.pop();
    }
    const list = ancestors.filter((it) => it.type === 'list');
    const lastList = last(list);
    const op = {
        insert: '\n',
        attributes: {
            list: item.checked === null
                ? (lastList === null || lastList === void 0 ? void 0 : lastList.ordered)
                    ? 'ordered'
                    : 'bullet'
                : item.checked
                    ? 'checked'
                    : 'unchecked',
        },
    };
    if (list.length > 1) {
        op.attributes.indent = list.length - 1;
    }
    ops.push(op);
    item.children
        .filter((it) => it.type === 'list')
        .forEach((it) => handle(it, [...ancestors, node]));
    return true;
};
const blockquote = ({ node, ancestors, ops, process: handle }) => {
    var _a, _b;
    if (node.type !== 'blockquote') {
        return;
    }
    ;
    node.children.forEach((it) => handle(it, [...ancestors, node]));
    if (((_a = last(ops)) === null || _a === void 0 ? void 0 : _a.insert) === '\n' && !((_b = last(ops)) === null || _b === void 0 ? void 0 : _b.attributes)) {
        ops.pop();
    }
    ops.push({
        insert: '\n',
        attributes: { blockquote: true },
    });
    return true;
};
const link = ({ node, ancestors, ops, process: handle }) => {
    if (node.type !== 'link') {
        return;
    }
    ;
    node.children.forEach((child) => {
        ops.push({
            insert: child.value,
            attributes: {
                link: node.url,
            },
        });
    });
    return true;
};
const image = ({ node, ancestors, ops, process: handle }) => {
    if (node.type !== 'image') {
        return;
    }
    ops.push({
        insert: {
            image: node.url,
        },
        attributes: {
            alt: node.alt,
        },
    });
    return true;
};
const code = ({ node, ancestors, ops, process: handle }) => {
    if (node.type !== 'code') {
        return;
    }
    ops.push({
        insert: node.value,
    }, {
        insert: '\n',
        attributes: {
            'code-block': true,
        },
    });
    // if (['paragraph'].includes(getNextType(ancestors, node))) {
    //   ops.push({ insert: '\n' } as Op)
    // }
    return true;
};
const inlineCode = ({ node, ancestors, ops, process: handle }) => {
    if (node.type !== 'inlineCode') {
        return;
    }
    ops.push({
        insert: node.value,
        attributes: { code: true },
    });
    return true;
};
const generic = ({ node, ancestors, ops }) => {
    ops.push({
        insert: toMarkdown(node, {
            extensions: [gfmToMarkdown()],
        }),
    });
    return true;
};
const breaking = ({ node, ancestors, ops, process }) => {
    if (node.type !== 'break') {
        return;
    }
    const prevType = getPreviousType(ancestors, node);
    const nextType = getNextType(ancestors, node);
    if (prevType !== 'text' || nextType !== 'text') {
        ops.push({ insert: '\n' });
        return true;
    }
    const old = ops[ops.length - 1];
    const child = last(ancestors).children;
    const nextNode = child[child.indexOf(node) + 1];
    ops[ops.length - 1] = {
        insert: old.insert + '\n' + nextNode.value,
    };
    child.splice(child.indexOf(nextNode), 1);
    return true;
};
function markdownToDelta(source, options = {}) {
    let ast;
    if (typeof source === 'string') {
        ast = fromMarkdown(source, {
            extensions: [gfm()],
            mdastExtensions: [gfmFromMarkdown()],
        });
    }
    else {
        ast = source;
    }
    const ops = [];
    function process(node, ancestors) {
        const handles = [
            root,
            paragraph,
            text,
            strong,
            heading,
            list,
            listItem,
            blockquote,
            link,
            image,
            code,
            inlineCode,
            breaking,
            generic,
        ];
        if (options.handle) {
            handles.unshift(options.handle);
        }
        for (const handle of handles) {
            const result = handle({ node, ancestors, ops, process: process });
            if (result) {
                return;
            }
        }
    }
    process(ast, []);
    return ops;
}
export default markdownToDelta;
